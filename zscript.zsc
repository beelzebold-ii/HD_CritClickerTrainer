version "4.14.2"

class CritClickerHandler:EventHandler {
	
	static const string critSounds[] = {
		"clicker",
		"metalgear",
		"ping",
		"earthbound",
		"teamfort"
	};
	
	array<string> blacklist;
	
	override void WorldThingDamaged(WorldEvent e){
		if(blacklist.Size()<=0){
			//console.printf("blacklist populated");
			string liststr = cvar.GetCVar("hdcritclicker_blacklist",players[consoleplayer]).GetString();
			//remove spaces
			liststr.Substitute(" ","");
			liststr = liststr.MakeLower();
			//populate our array
			liststr.Split(blacklist,",",TOK_SKIPEMPTY);
			
			//add a string that can't match any bullet's classname to prevent the
			//array from being populated more than once
			blacklist.Push("object");
		}
		
		bool printconsole = false;
		bool sourcelog = cvar.GetCVar("hdcritclicker_log",players[consoleplayer]).GetBool();
		bool printinfo = cvar.GetCVar("hdcritclicker_info",players[consoleplayer]).GetBool();
		bool onlyprintoncrit = cvar.GetCVar("hdcritclicker_critonly",players[consoleplayer]).GetBool();
		bool ignorefragments = true;
		
		if(e.DamageType == "bashing" && e.Inflictor is "HDBulletActor"){
			//an HDBulletActor has dealt bashing damage to something
			//as far as I'm aware, this is called once per bullet impact
			//and is called every bullet impact
			//(or at least every impact relevant to crits?)
			//(idk if bullet-shield impacts do bashing)
			
			//it does actually seem as though in some cases an actor which is
			//already significantly mangled won't receive this bashing damage.
			//this is probably not really a problem, but I guess I'll see how
			//common it is.
			
			//if the bullet's classname is in the blacklist, don't report anything
			//need to do some shenanigans to make it not case sensitive
			string classn = e.Inflictor.GetClassName();
			classn = classn.MakeLower();
			if(blacklist.Find(classn) < blacklist.Size()) return;
			//don't report *anything* about bullet>shield hits
			if(e.Thing.countinv("HDMagicShield") > 0) return;
			//all crits are discarded if this returns true
			//but this just means that the tempcavity shockbash damage just outright killed them
			//we should still reward the trainee in this case for their desired behavior
			//console.printf("shockbash: "..e.Damage);
			//if(HDMath.IsDead(e.Thing)) return;
			
			bool iscritzone = false;
			bool toolow = false;
			
			//if I was STUPID and didn't look well enough at the stepping code
			//in HDBulletActor, then I would get hitpos with a bullet linetracer.
			//which I'm not btw. I totally checked before writing this.
			
			//instead, I'm smart and automagically knew that the bullet's
			//position is set to the hitpos, stepped back by a tenth of its
			//velocity's unit vector. this happens shortly before OnHitActor.
			vector3 hitpos = e.Inflictor.pos + (e.Inflictor.vel.unit() * 0.1);
			
			double mincritheight = e.Thing.height*0.6;
			double basehitz = hitpos.z - e.Thing.pos.z;
			
			//is our shot high enough to hit the cns?
			if(basehitz > mincritheight){
				//we're above the waist now
				toolow = false;
			}else{
				toolow = true;
			}
			
			double hitangle = actor.absangle(e.Inflictor.angle,e.Inflictor.angleto(e.Thing));
			double tinyspeedsquared = e.Inflictor.speed * e.Inflictor.speed * 0.000001;
			
			//is our shot centered enough?
			if(hitangle < 12+frandom(0,tinyspeedsquared*7+e.Inflictor.stamina*0.001)){
				
				//again, is our shot high enough to hit the cns?
				//I'm not messing with calculating bullet penetration, sorry.
				if(toolow==false){
					//we've got a CRIT!!!
					iscritzone = true;
				}
			}
			
			bool pentocore = true; //if the round penetrates to the core of the target
			bool checkpen = cvar.GetCVar("hdcritclicker_checkpen",players[consoleplayer]).GetBool();
			if(iscritzone && checkpen){
				//check penetration only if the crit would be valid right now
				//hehehehe hehehe shut up
				double penetration = HDBulletActor(e.Inflictor).Penetration();
				double deemedwidth = e.Thing.radius * 1.8; //minimum possible, meaning if a crit *can* happen we'll click it
				
				//we also need to check the target's "penshell" (innate bullet resistance/armor)
				if(e.Thing is 'HDActor'){
					HDActor hdaa = HDActor(e.Thing);
					
					//determine bullet resistance ([code mostly ripped from hdest])
					double penshell=max(hdaa.bulletresistance(hitangle),hdaa.bulletshell(hitpos,hitangle));
					
					//WE WILL BE SKIPPING HDDAMAGEHANDLERS
					//I don't want bullets to accidentally end up damaging armor twice
					//or really for this to affect the play scope at all. cos desyncs and stuff.
					
					//I still don't know if this is even remotely netplay compatible.
					//someone else will have to test that for me or let me know just by
					//what they see here in the code! until then I will ignore the
					//very likely problem.
					
					if(penshell<=0)penshell=0;
					else penshell*=1.-frandom(0,hitangle*0.004);
					
					//console.printf("penshell: "..penshell);
					
					//apply final armour
					penetration-=penshell;
				}
				
				//console.printf("penetration: "..penetration.."; necessary depth "..deemedwidth*0.4);
				
				//if the bullet does not go to the center fifth of the target
				//then we throw out the crit.
				if(penetration <= deemedwidth*0.4){
					iscritzone = false;
					//and report the reason why for the console logging code
					pentocore = false;
				}
			}
			
			//crit confirmation will happen after it's already thoroughly calculated,
			//in case something after the other calculations invalidates the crit.
			if(iscritzone){
				cvar sfx = cvar.GetCVar("hdcritclicker_sound",players[consoleplayer]);
				cvar vol = cvar.GetCVar("hdcritclicker_vol",players[consoleplayer]);
				e.DamageSource.A_StartSound("critsnd/"..critSounds[sfx.GetInt()],CHAN_AUTO,0,vol.GetFloat(),ATTN_STATIC);
			}
			
			if(!e.DamageSource || !(e.DamageSource is "playerpawn")) return;
			
			if(printconsole){
				console.printf(e.Inflictor.GetClassName().." hit "..e.Thing.GetClassName());
				console.printf(string.format("Angle deviation: %.1f",hitangle));
				if(toolow)
					console.printf("Shot placed too low.");
				if(iscritzone) console.printf("CRIT!!!");
			}else{
				if(sourcelog && (onlyprintoncrit == false || iscritzone == true)){
					if(printinfo){
						e.DamageSource.A_Log("Bullet hit "..e.Thing.GetTag(),true);
						e.DamageSource.A_Log(string.format("Angle deviation: %.1f",hitangle),true);
						if(toolow)
							e.DamageSource.A_Log("Shot placed too low.",true);
						if(!pentocore)
							e.DamageSource.A_Log("Shot didn't penetrate to CNS.",true);
					}
					if(iscritzone) e.DamageSource.A_Log("CRIT!!!",true);
				}
			}
		}
	}
}